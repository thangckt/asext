{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>asext</code> Documentation","text":""},{"location":"#asext","title":"<code>asext</code>","text":"<p>Python package extends functions of ASE (Atomic Simulation Environment).</p> <p>Developed and maintained by C.Thang Nguyen</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#asext","title":"<code>asext</code>","text":"<p>Python package extends functions of ASE (Atomic Simulation Environment).</p> <p>Developed and maintained by C.Thang Nguyen</p> <p>Modules:</p> <ul> <li> <code>cell</code>           \u2013            </li> <li> <code>io</code>           \u2013            </li> <li> <code>struct</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>ASEXT_ROOT</code>           \u2013            </li> <li> <code>__author__</code>           \u2013            </li> <li> <code>__contact__</code>           \u2013            </li> </ul>"},{"location":"api/#asext.ASEXT_ROOT","title":"<code>ASEXT_ROOT = Path(__file__).parent</code>  <code>module-attribute</code>","text":""},{"location":"api/#asext.__author__","title":"<code>__author__ = 'C.Thang Nguyen'</code>  <code>module-attribute</code>","text":""},{"location":"api/#asext.__contact__","title":"<code>__contact__ = 'http://thangckt.github.io/email'</code>  <code>module-attribute</code>","text":""},{"location":"api/#asext.cell","title":"<code>cell</code>","text":"<p>Classes:</p> <ul> <li> <code>AseCell</code>           \u2013            </li> <li> <code>CellTransform</code>           \u2013            <p>Tranform the cell and atom properties from <code>old_cell</code> to <code>new_cell</code> orientations.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>make_upper_triangular_cell</code>             \u2013              <p>Atoms with a box is an upper triangular matrix is a requirement to run <code>NPT</code> class in ASE.</p> </li> <li> <code>make_lower_triangular_cell</code>             \u2013              <p>Converts the cell matrix of <code>atoms</code> into a lower triangular, to be used in LAMMPS:</p> </li> <li> <code>make_triangular_cell_extxyz</code>             \u2013              <p>Make the cell of atoms in extxyz file to be triangular.</p> </li> <li> <code>rotate_struct_property</code>             \u2013              <p>Rotate atomic structure and its properties to match a new cell orientation.</p> </li> </ul>"},{"location":"api/#asext.cell.AseCell","title":"<code>AseCell(array: np.ndarray)</code>","text":"<p>               Bases: <code>Cell</code></p> <p>Methods:</p> <ul> <li> <code>lower_triangular_form</code>             \u2013              <p>Rename original function <code>Cell.standard_form()</code>, see https://gitlab.com/ase/ase/-/blob/master/ase/cell.py?ref_type=heads#L333</p> </li> <li> <code>upper_triangular_form</code>             \u2013              <p>Rotate axes such that the unit cell is an upper triangular matrix.</p> </li> </ul>"},{"location":"api/#asext.cell.AseCell.lower_triangular_form","title":"<code>lower_triangular_form() -&gt; tuple[Cell, np.ndarray]</code>","text":"<p>Rename original function <code>Cell.standard_form()</code>, see https://gitlab.com/ase/ase/-/blob/master/ase/cell.py?ref_type=heads#L333</p>"},{"location":"api/#asext.cell.AseCell.upper_triangular_form","title":"<code>upper_triangular_form() -&gt; tuple[Cell, np.ndarray]</code>","text":"<p>Rotate axes such that the unit cell is an upper triangular matrix.</p>"},{"location":"api/#asext.cell.CellTransform","title":"<code>CellTransform(old_cell: np.ndarray, new_cell: np.ndarray, pure_rotation: bool = True)</code>","text":"<p>Tranform the cell and atom properties from <code>old_cell</code> to <code>new_cell</code> orientations.</p> <p>The idea is compute a linear transformation that maps the old cell to the new cell. <code>A = solve(old_cell, new_cell) = old_cell^(-1) new_cell</code></p> <p>Generally, this linear transformation <code>A</code> can include rotation R + shear/reshape U (stretching and shearing), i.e., <code>A = R * U</code>.</p> <p>Therefore, this transformation can be used in two ways: 1. Directly apply <code>A</code> that includes both rotation and shear/stretch. (should avoid using this, since it is not clear how to transform properties like stress/forces) 2. Extract only the rotation part <code>R</code> from <code>A</code> (using polar decomposition), and use it to rotate vectors/tensors, ignoring shear/reshape change.     - Extract the closest pure rotation <code>R</code> from <code>A</code> (using polar decomposition)     - Use that <code>R</code> to rotate positions, forces, stress, etc.</p> <p>Parameters:</p> <ul> <li> <code>old_cell</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the old cell.</p> </li> <li> <code>new_cell</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the new cell.</p> </li> <li> <code>pure_rotation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only use the rotation part of the transformation. Defaults to True.</p> </li> </ul> Note <ul> <li><code>np.linalg.solve(A, B)</code> solves <code>AX = B</code> for <code>X</code>. May fail if <code>A</code> is singular (square matrix with a determinant of zero, det(A)=0).</li> <li>Rotation matrix is derived from QR decomposition of the cell, following Prism class</li> </ul> <p>Methods:</p> <ul> <li> <code>vectors_forward</code>             \u2013              <p>Rotate vectors from the old_cell's orient to the new_cell's orient.</p> </li> <li> <code>vectors_backward</code>             \u2013              <p>Rotate vectors back from the new_cell to the old_cell. Same as Prism.vector_to_ase</p> </li> <li> <code>tensor_forward</code>             \u2013              <p>Rotate the tensor from the old_cell's orient to the new_cell's orient.</p> </li> <li> <code>tensor_backward</code>             \u2013              <p>Rotate the tensor back from the new_cell to the old_cell. Same as Prism.tensor_to_ase</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>old_cell</code>           \u2013            </li> <li> <code>new_cell</code>           \u2013            </li> <li> <code>R</code>           \u2013            </li> </ul>"},{"location":"api/#asext.cell.CellTransform.old_cell","title":"<code>old_cell = np.asarray(old_cell, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#asext.cell.CellTransform.new_cell","title":"<code>new_cell = np.asarray(new_cell, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#asext.cell.CellTransform.R","title":"<code>R = _polar_rotation(A)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#asext.cell.CellTransform.vectors_forward","title":"<code>vectors_forward(vec: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate vectors from the old_cell's orient to the new_cell's orient.</p> <p>Parameters:</p> <ul> <li> <code>vec</code>               (<code>ndarray</code>)           \u2013            <p>Nx3 matrix represent the vector properties. (positions, forces, etc. each row is a vector)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotated vectors.</p> </li> </ul>"},{"location":"api/#asext.cell.CellTransform.vectors_backward","title":"<code>vectors_backward(vec: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate vectors back from the new_cell to the old_cell. Same as Prism.vector_to_ase</p>"},{"location":"api/#asext.cell.CellTransform.tensor_forward","title":"<code>tensor_forward(tensor: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate the tensor from the old_cell's orient to the new_cell's orient. (T' = R\u1d40 T R) rotates the tensor into the rotated coordinate system</p> <p>Parameters:</p> <ul> <li> <code>tensor</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the tensor properties. (e.g., 3x3 stress tensor)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Transformed tensor.</p> </li> </ul>"},{"location":"api/#asext.cell.CellTransform.tensor_backward","title":"<code>tensor_backward(tensor: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate the tensor back from the new_cell to the old_cell. Same as Prism.tensor_to_ase (T = R T' R\u1d40) rotates the tensor back into the original coordinate system</p>"},{"location":"api/#asext.cell.make_upper_triangular_cell","title":"<code>make_upper_triangular_cell(atoms: Atoms, zero_tol: float = 1e-12) -&gt; Atoms</code>","text":"<p>Atoms with a box is an upper triangular matrix is a requirement to run <code>NPT</code> class in ASE. [[ ax, ay, az ]  [  0, by, bz ]  [  0,  0, cz ]]</p>"},{"location":"api/#asext.cell.make_lower_triangular_cell","title":"<code>make_lower_triangular_cell(atoms: Atoms, zero_tol: float = 1e-12) -&gt; Atoms</code>","text":"<p>Converts the cell matrix of <code>atoms</code> into a lower triangular, to be used in LAMMPS: [[ ax,  0,  0 ]  [ bx, by,  0 ]  [ cx, cy, cz ]]</p>"},{"location":"api/#asext.cell.make_triangular_cell_extxyz","title":"<code>make_triangular_cell_extxyz(extxyz_file: str, form: str = 'lower') -&gt; None</code>","text":"<p>Make the cell of atoms in extxyz file to be triangular. Args:     extxyz_file (str): Path to the extxyz file.     form (str): 'upper' or 'lower'. Defaults to 'lower'.</p>"},{"location":"api/#asext.cell._polar_rotation","title":"<code>_polar_rotation(A: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Return the closest proper rotation to matrix A (polar decomposition).</p> <p>The purpose of this function is to get only the orientation difference, ignoring any shear/stretch.</p> <p>Remind: Given a linear transformation <code>A=old_cell^(-1) new_cell</code> (carry old cell vectors into the new cell vectors), we can decompose it into a rotation R and a symmetric positive semi-definite matrix U (which represents stretch/shear) such that <code>A = R * U</code>. The rotation matrix R captures the pure rotational component of the transformation, while U captures the deformation (stretching and shearing) component.</p>"},{"location":"api/#asext.cell.rotate_struct_property","title":"<code>rotate_struct_property(struct: Atoms, new_cell: np.ndarray, wrap: bool = False, custom_vector_props: list[str] | None = None, custom_tensor_props: list[str] | None = None) -&gt; Atoms</code>","text":"<p>Rotate atomic structure and its properties to match a new cell orientation.</p> <p>Parameters:</p> <ul> <li> <code>struct</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object.</p> </li> <li> <code>new_cell</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the new cell.</p> </li> <li> <code>wrap</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, wrap atoms into the new cell.</p> </li> <li> <code>custom_vector_props</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of vector properties to rotate. This allows to set vector properties with custom names.</p> </li> <li> <code>custom_tensor_props</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of tensor properties to rotate. This allows to set tensor properties with custom names.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>ase.Atoms: Atoms object with rotated properties.</p> </li> </ul> Note <ul> <li>Important note: <code>deepcopy(struct)</code> copies the <code>struct.calc</code> object, but <code>struct.copy()</code> does not.</li> </ul>"},{"location":"api/#asext.io","title":"<code>io</code>","text":"<p>Modules:</p> <ul> <li> <code>lmpdata</code>           \u2013            </li> <li> <code>readwrite</code>           \u2013            </li> </ul>"},{"location":"api/#asext.io.lmpdata","title":"<code>lmpdata</code>","text":"<p>Functions:</p> <ul> <li> <code>read_lammps_dump_text</code>             \u2013              <p>Process cleartext lammps dumpfiles</p> </li> <li> <code>write_lammps_data</code>             \u2013              <p>Write atomic structure data to a LAMMPS data file.</p> </li> </ul>"},{"location":"api/#asext.io.lmpdata._lammps_data_to_ase_atoms","title":"<code>_lammps_data_to_ase_atoms(data, colnames, cell, celldisp, pbc=False, atomsobj=Atoms, order=True, specorder=None, prismobj=None, units='metal')</code>","text":"<p>Extract positions and other per-atom parameters and create Atoms</p> <p>:param data: per atom data :param colnames: index for data :param cell: cell dimensions :param celldisp: origin shift :param pbc: periodic boundaries :param atomsobj: function to create ase-Atoms object :param order: sort atoms by id. Might be faster to turn off. Disregarded in case <code>id</code> column is not given in file. :param specorder: list of species to map lammps types to ase-species (usually .dump files to not contain type to species mapping) :param prismobj: Coordinate transformation between lammps and ase :type prismobj: Prism :param units: lammps units for unit transformation between lammps and ase :returns: Atoms object :rtype: Atoms</p> <p>Notes: - The original function in <code>ase.io.lammpsrun.lammps_data_to_ase_atoms</code> can not recover the atom types. This function is modified to save the atom types if <code>type</code> column is given in the LAMMPS dump file.</p>"},{"location":"api/#asext.io.lmpdata.read_lammps_dump_text","title":"<code>read_lammps_dump_text(file: str, index=-1, **kwargs)</code>","text":"<p>Process cleartext lammps dumpfiles</p> <p>:param fileobj: filestream providing the trajectory data :param index: integer or slice object (default: get the last timestep) :returns: list of Atoms objects :rtype: list</p> <p>Notes: - This function is a modified version of <code>ase.io.lammpsrun.read_lammps_dump_text</code> to allow storing atom types if <code>type</code> column is given in the LAMMPS dump file.</p>"},{"location":"api/#asext.io.lmpdata.write_lammps_data","title":"<code>write_lammps_data(file: str, atoms: Atoms, *, specorder: list = None, reduce_cell: bool = False, force_skew: bool = False, prismobj: Prism = None, write_image_flags: bool = False, masses: bool = False, velocities: bool = False, units: str = 'metal', bonds: bool = True, atom_style: str = 'atomic')</code>","text":"<p>Write atomic structure data to a LAMMPS data file.</p>"},{"location":"api/#asext.io.lmpdata.write_lammps_data--parameters","title":"Parameters","text":"<p>fd : file|str     File to which the output will be written. atoms : Atoms     Atoms to be written. specorder : list[str], optional     Chemical symbols in the order of LAMMPS atom types, by default None force_skew : bool, optional     Force to write the cell as a     <code>triclinic &lt;https://docs.lammps.org/Howto_triclinic.html&gt;</code>__ box,     by default False reduce_cell : bool, optional     Whether the cell shape is reduced or not, by default False prismobj : Prism|None, optional     Prism, by default None write_image_flags : bool, default False     If True, the image flags, i.e., in which images of the periodic     simulation box the atoms are, are written. masses : bool, optional     Whether the atomic masses are written or not, by default False velocities : bool, optional     Whether the atomic velocities are written or not, by default False units : str, optional     <code>LAMMPS units &lt;https://docs.lammps.org/units.html&gt;</code>,     by default 'metal' bonds : bool, optional     Whether the bonds are written or not. Bonds can only be written     for atom_style='full', by default True atom_style : {'atomic', 'charge', 'full'}, optional     <code>LAMMPS atom style &lt;https://docs.lammps.org/atom_style.html&gt;</code>,     by default 'atomic'</p> <p>Notes: - This function is a modified version of <code>ase.io.lammpsdata.write_lammps_data</code> to allow writing atom types based on <code>atoms.arrays['type']</code> if it exists. Otherwise, the atom types are assigned based on the order of <code>specorder</code> or sorted chemical symbols.</p>"},{"location":"api/#asext.io.lmpdata._get_types","title":"<code>_get_types(atoms: Atoms, species: list)</code>","text":""},{"location":"api/#asext.io.lmpdata._get_symbols_by_types","title":"<code>_get_symbols_by_types(atoms: Atoms)</code>","text":""},{"location":"api/#asext.io.readwrite","title":"<code>readwrite</code>","text":"<p>Functions:</p> <ul> <li> <code>read_extxyz</code>             \u2013              <p>Read extxyz file. The existing <code>ase.io.read</code> returns a single Atoms object if file contains only one frame. This function will return a list of Atoms object.</p> </li> <li> <code>write_extxyz</code>             \u2013              <p>Write a list of Atoms object to an extxyz file. The existing <code>ase.io.write</code> function does not support writing file if the parent directory does not exist. This function will overcome this problem.</p> </li> <li> <code>read_lmpdump</code>             \u2013              <p>Shortcut to <code>ase.io.lammpsrun.read_lammps_dump</code> function.</p> </li> <li> <code>write_lmpdata</code>             \u2013              <p>Shortcut to <code>ase.io.lammpsdata.write_lammps_data</code> function.</p> </li> <li> <code>extxyz2lmpdata</code>             \u2013              <p>Convert extxyz file to LAMMPS data file.</p> </li> <li> <code>lmpdata2extxyz</code>             \u2013              <p>Convert LAMMPS data file to extxyz file.</p> </li> <li> <code>lmpdump2extxyz</code>             \u2013              <p>Convert LAMMPS dump file to extxyz file.</p> </li> </ul>"},{"location":"api/#asext.io.readwrite.read_extxyz","title":"<code>read_extxyz(extxyz_file: str, index=':') -&gt; list[Atoms]</code>","text":"<p>Read extxyz file. The existing <code>ase.io.read</code> returns a single Atoms object if file contains only one frame. This function will return a list of Atoms object.</p> <p>Parameters:</p> <ul> <li> <code>extxyz_file</code>               (<code>str</code>)           \u2013            <p>Path to the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list[Atoms]</code> )          \u2013            <p>List of Atoms object.</p> </li> </ul> Note <ul> <li><code>ase.io.read</code> returns a single Atoms object or a list of Atoms object, depending on the <code>index</code> argument.<ul> <li><code>index=\":\"</code> will always return a list.</li> <li><code>index=0</code> or <code>index=-1</code> will return a single Atoms object.</li> </ul> </li> <li>this function will always return a list of Atoms object, even <code>index=0</code> or <code>index=-1</code></li> </ul>"},{"location":"api/#asext.io.readwrite.write_extxyz","title":"<code>write_extxyz(outfile: str, structs: list[Atoms]) -&gt; None</code>","text":"<p>Write a list of Atoms object to an extxyz file. The existing <code>ase.io.write</code> function does not support writing file if the parent directory does not exist. This function will overcome this problem.</p> <p>Parameters:</p> <ul> <li> <code>structs</code>               (<code>list</code>)           \u2013            <p>List of Atoms object.</p> </li> <li> <code>outfile</code>               (<code>str</code>)           \u2013            <p>Path to the output file.</p> </li> </ul>"},{"location":"api/#asext.io.readwrite.read_lmpdump","title":"<code>read_lmpdump(lmpdump_file: str, index=-1, units='metal', **kwargs) -&gt; list[Atoms]</code>","text":"<p>Shortcut to <code>ase.io.lammpsrun.read_lammps_dump</code> function.</p> <p>Parameters:</p> <ul> <li> <code>lmpdump_file</code>               (<code>str</code>)           \u2013            <p>Path to the LAMMPS dump file.</p> </li> <li> <code>index</code>               (<code>int | list[int]</code>, default:                   <code>-1</code> )           \u2013            <p>integer or slice object (default: get the last timestep)</p> </li> <li> <code>order</code>               (<code>bool</code>)           \u2013            <p>sort atoms by id. Might be faster to turn off. Default: True</p> </li> <li> <code>specorder</code>               (<code>list[str]</code>)           \u2013            <p>list of species to map lammps types to ase-species. Default: None</p> </li> <li> <code>units</code>               (<code>str</code>, default:                   <code>'metal'</code> )           \u2013            <p>lammps units for unit transformation between lammps and ase</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list[Atoms]</code> )          \u2013            <p>List of Atoms object.</p> </li> </ul>"},{"location":"api/#asext.io.readwrite.write_lmpdata","title":"<code>write_lmpdata(file: str, atoms: Atoms, *, specorder: list = None, reduce_cell: bool = False, force_skew: bool = False, prismobj: Prism = None, write_image_flags: bool = False, masses: bool = True, velocities: bool = False, units: str = 'metal', bonds: bool = True, atom_style: str = 'atomic') -&gt; None</code>","text":"<p>Shortcut to <code>ase.io.lammpsdata.write_lammps_data</code> function.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>str</code>)           \u2013            <p>File to which the output will be written.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms to be written.</p> </li> <li> <code>specorder</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>Chemical symbols in the order of LAMMPS atom types, by default None</p> </li> <li> <code>force_skew</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force to write the cell as a <code>triclinic &lt;https://docs.lammps.org/Howto_triclinic.html&gt;</code> box, by default False</p> </li> <li> <code>reduce_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the cell shape is reduced or not, by default False</p> </li> <li> <code>prismobj</code>               (<code>Prism | None</code>, default:                   <code>None</code> )           \u2013            <p>Prism, by default None</p> </li> <li> <code>write_image_flags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>default False. If True, the image flags, i.e., in which images of the periodic simulation box the atoms are, are written.</p> </li> <li> <code>masses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the atomic masses are written or not, by default True</p> </li> <li> <code>velocities</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the atomic velocities are written or not, by default False</p> </li> <li> <code>units</code>               (<code>str</code>, default:                   <code>'metal'</code> )           \u2013            <p><code>LAMMPS units &lt;https://docs.lammps.org/units.html&gt;</code>, by default 'metal'</p> </li> <li> <code>bonds</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bonds are written or not. Bonds can only be written for atom_style='full', by default True</p> </li> <li> <code>atom_style </code>           \u2013            <p>{'atomic', 'charge', 'full'}, optional. <code>LAMMPS atom style &lt;https://docs.lammps.org/atom_style.html&gt;</code>, by default 'atomic'</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"api/#asext.io.readwrite.extxyz2lmpdata","title":"<code>extxyz2lmpdata(extxyz_file: str, lmpdata_file: str, masses: bool = True, units: str = 'metal', atom_style: str = 'atomic', **kwargs) -&gt; list[str]</code>","text":"<p>Convert extxyz file to LAMMPS data file. Note:     - need to save 'original_cell' to able to revert the original orientation of the crystal.     - Use <code>atoms.arrays['type']</code> to set atom types when convert from <code>extxyz</code> to <code>lammpsdata</code> file.</p>"},{"location":"api/#asext.io.readwrite.lmpdata2extxyz","title":"<code>lmpdata2extxyz(lmpdata_file: str, extxyz_file: str, original_cell_file: str = None)</code>","text":"<p>Convert LAMMPS data file to extxyz file.</p>"},{"location":"api/#asext.io.readwrite.lmpdump2extxyz","title":"<code>lmpdump2extxyz(lmpdump_file: str, extxyz_file: str, index: int | slice = -1, original_cell_file: str = None, stress_file: str = None, lammps_units: str = 'metal')</code>","text":"<p>Convert LAMMPS dump file to extxyz file.</p> <p>Parameters:</p> <ul> <li> <code>lmpdump_file</code>               (<code>str</code>)           \u2013            <p>Path to the LAMMPS dump file.</p> </li> <li> <code>extxyz_file</code>               (<code>str</code>)           \u2013            <p>Path to the output extxyz file.</p> </li> <li> <code>original_cell_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the text file contains original_cell. It should a simple text file that can write/read with numpy. If not provided, try to find in the same directory as <code>lmpdump_file</code> with the extension <code>.original_cell</code>. Defaults to None.</p> </li> <li> <code>stress_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the text file contains stress tensor. Defaults to None.</p> </li> </ul> Restriction <ul> <li>Current ver: stress is mapped based on frame_index, it requires that frames in text stress file must be in the same \"length and order\" as in the LAMMPS dump file.</li> <li><code>struct.info.get(\"timestep\")</code> is a new feature in ASE 3.25 ?</li> </ul>"},{"location":"api/#asext.struct","title":"<code>struct</code>","text":"<p>Functions:</p> <ul> <li> <code>strain_struct</code>             \u2013              <p>Apply engineering strain to an ASE Atoms structure along lattice vectors a, b, c.</p> </li> <li> <code>perturb_struct</code>             \u2013              <p>Perturb the atoms by random displacements. This method adds random displacements to the atomic positions. See more</p> </li> <li> <code>slice_struct</code>             \u2013              <p>Slice structure into the first subcell by given numbers along a, b, c (cell vector) directions.</p> </li> <li> <code>align_struct_min_pos</code>             \u2013              <p>Align min atoms position to the min cell corner (0,0,0)</p> </li> <li> <code>set_vacuum</code>             \u2013              <p>This function sets vacuum along cell vectors a, b, c.</p> </li> <li> <code>check_bad_box_extxyz</code>             \u2013              <p>Check structure in extxyz file whether it has bad box.</p> </li> <li> <code>check_bad_box</code>             \u2013              <p>Check if a simulation box is \"bad\" based on given criteria.</p> </li> </ul>"},{"location":"api/#asext.struct.strain_struct","title":"<code>strain_struct(struct_in: Atoms, strains: list = [0, 0, 0]) -&gt; Atoms</code>","text":"<p>Apply engineering strain to an ASE Atoms structure along lattice vectors a, b, c.</p> <p>Parameters:</p> <ul> <li> <code>struct</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object.</p> </li> <li> <code>strains</code>               (<code>list[float]</code>, default:                   <code>[0, 0, 0]</code> )           \u2013            <p>Engineering strains [\u03b5_a, \u03b5_b, \u03b5_c]. New_length = old_length * (1 + \u03b5).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code> (              <code>Atoms</code> )          \u2013            <p>New strained structure with scaled cell and atom positions.</p> </li> </ul>"},{"location":"api/#asext.struct.perturb_struct","title":"<code>perturb_struct(struct: Atoms, std_disp: float) -&gt; Atoms</code>","text":"<p>Perturb the atoms by random displacements. This method adds random displacements to the atomic positions. See more</p>"},{"location":"api/#asext.struct.slice_struct","title":"<code>slice_struct(struct_in: Atoms, slice_num=(1, 1, 1), tol=1e-05) -&gt; Atoms</code>","text":"<p>Slice structure into the first subcell by given numbers along a, b, c (cell vector) directions.</p>"},{"location":"api/#asext.struct.align_struct_min_pos","title":"<code>align_struct_min_pos(struct: Atoms) -&gt; Atoms</code>","text":"<p>Align min atoms position to the min cell corner (0,0,0)</p>"},{"location":"api/#asext.struct.set_vacuum","title":"<code>set_vacuum(struct_in: Atoms, distances: list = [0.0, 0.0, 0.0]) -&gt; Atoms</code>","text":"<p>This function sets vacuum along cell vectors a, b, c.</p> <p>Parameters:</p> <ul> <li> <code>struct</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object to add vacuum.</p> </li> <li> <code>distances</code>               (<code>list</code>, default:                   <code>[0.0, 0.0, 0.0]</code> )           \u2013            <p>Distances to add along cell vectors a, b, c (not x, y, z dims in Cartersian axes). Must be a list of 3 floats.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>struct</code> (              <code>Atoms</code> )          \u2013            <p>A new Atoms object with an expanded cell and centered atoms.</p> </li> </ul> Notes <ul> <li><code>atoms.center()</code> sets vacuum on both sides of the cell along the specified axis. So the total vacuum is twice the input value. This function is different in that, it set total vacuum equal to the input value.</li> </ul>"},{"location":"api/#asext.struct.check_bad_box_extxyz","title":"<code>check_bad_box_extxyz(extxyz_file: str, criteria: dict = {'length_ratio': 100, 'wrap_ratio': 0.5, 'tilt_ratio': 0.5}) -&gt; list[int]</code>","text":"<p>Check structure in extxyz file whether it has bad box. Return:     a file remarking the bad box frames.</p>"},{"location":"api/#asext.struct.check_bad_box","title":"<code>check_bad_box(struct: Atoms, criteria: dict = {'length_ratio': 20, 'wrap_ratio': 0.5, 'tilt_ratio': 0.5}) -&gt; bool</code>","text":"<p>Check if a simulation box is \"bad\" based on given criteria.</p>"},{"location":"api/#asext.struct.check_bad_box--args","title":"Args:","text":"<p>struct : ase.Atoms     Atoms object containing the atomic structure. criteria : dict     A dictionary of criteria to check, which contains pairs of {'criteria_name': threshold_value}.     Available criteria:     - <code>length_ratio</code>: The ratio of the longest to the shortest cell vector.       - Formula: max(|a|, |b|, |c|) / min(|a|, |b|, |c|)       - Prevents highly elongated simulation boxes.     - <code>wrap_ratio</code>: Checks if one cell vector component is excessively wrapped around another.       - Formula: [b_x / a_x, c_y / b_y, c_x / a_x]       - Prevents excessive skewing.     - <code>tilt_ratio</code>: Measures tilting of cell vectors relative to their axes.       - Formula: [b_x / b_y, c_y / c_z, c_x / c_z]       - Avoids excessive tilting that may disrupt periodic boundaries.</p>"},{"location":"api/#asext.struct.check_bad_box--returns","title":"Returns:","text":"<p>is_bad : bool     True if the simulation box violates any of the given criteria, otherwise False.</p>"},{"location":"api/#asext.struct.check_bad_box--raises","title":"Raises:","text":"<p>RuntimeError     If an unknown criterion key is provided.</p>"},{"location":"cell/","title":"cell","text":""},{"location":"cell/#asext.cell","title":"<code>asext.cell</code>","text":"<p>Classes:</p> <ul> <li> <code>AseCell</code>           \u2013            </li> <li> <code>CellTransform</code>           \u2013            <p>Tranform the cell and atom properties from <code>old_cell</code> to <code>new_cell</code> orientations.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>make_upper_triangular_cell</code>             \u2013              <p>Atoms with a box is an upper triangular matrix is a requirement to run <code>NPT</code> class in ASE.</p> </li> <li> <code>make_lower_triangular_cell</code>             \u2013              <p>Converts the cell matrix of <code>atoms</code> into a lower triangular, to be used in LAMMPS:</p> </li> <li> <code>make_triangular_cell_extxyz</code>             \u2013              <p>Make the cell of atoms in extxyz file to be triangular.</p> </li> <li> <code>rotate_struct_property</code>             \u2013              <p>Rotate atomic structure and its properties to match a new cell orientation.</p> </li> </ul>"},{"location":"cell/#asext.cell.AseCell","title":"<code>AseCell(array: np.ndarray)</code>","text":"<p>               Bases: <code>Cell</code></p> <p>Methods:</p> <ul> <li> <code>lower_triangular_form</code>             \u2013              <p>Rename original function <code>Cell.standard_form()</code>, see https://gitlab.com/ase/ase/-/blob/master/ase/cell.py?ref_type=heads#L333</p> </li> <li> <code>upper_triangular_form</code>             \u2013              <p>Rotate axes such that the unit cell is an upper triangular matrix.</p> </li> </ul>"},{"location":"cell/#asext.cell.AseCell.lower_triangular_form","title":"<code>lower_triangular_form() -&gt; tuple[Cell, np.ndarray]</code>","text":"<p>Rename original function <code>Cell.standard_form()</code>, see https://gitlab.com/ase/ase/-/blob/master/ase/cell.py?ref_type=heads#L333</p>"},{"location":"cell/#asext.cell.AseCell.upper_triangular_form","title":"<code>upper_triangular_form() -&gt; tuple[Cell, np.ndarray]</code>","text":"<p>Rotate axes such that the unit cell is an upper triangular matrix.</p>"},{"location":"cell/#asext.cell.CellTransform","title":"<code>CellTransform(old_cell: np.ndarray, new_cell: np.ndarray, pure_rotation: bool = True)</code>","text":"<p>Tranform the cell and atom properties from <code>old_cell</code> to <code>new_cell</code> orientations.</p> <p>The idea is compute a linear transformation that maps the old cell to the new cell. <code>A = solve(old_cell, new_cell) = old_cell^(-1) new_cell</code></p> <p>Generally, this linear transformation <code>A</code> can include rotation R + shear/reshape U (stretching and shearing), i.e., <code>A = R * U</code>.</p> <p>Therefore, this transformation can be used in two ways: 1. Directly apply <code>A</code> that includes both rotation and shear/stretch. (should avoid using this, since it is not clear how to transform properties like stress/forces) 2. Extract only the rotation part <code>R</code> from <code>A</code> (using polar decomposition), and use it to rotate vectors/tensors, ignoring shear/reshape change.     - Extract the closest pure rotation <code>R</code> from <code>A</code> (using polar decomposition)     - Use that <code>R</code> to rotate positions, forces, stress, etc.</p> <p>Parameters:</p> <ul> <li> <code>old_cell</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the old cell.</p> </li> <li> <code>new_cell</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the new cell.</p> </li> <li> <code>pure_rotation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only use the rotation part of the transformation. Defaults to True.</p> </li> </ul> Note <ul> <li><code>np.linalg.solve(A, B)</code> solves <code>AX = B</code> for <code>X</code>. May fail if <code>A</code> is singular (square matrix with a determinant of zero, det(A)=0).</li> <li>Rotation matrix is derived from QR decomposition of the cell, following Prism class</li> </ul> <p>Methods:</p> <ul> <li> <code>vectors_forward</code>             \u2013              <p>Rotate vectors from the old_cell's orient to the new_cell's orient.</p> </li> <li> <code>vectors_backward</code>             \u2013              <p>Rotate vectors back from the new_cell to the old_cell. Same as Prism.vector_to_ase</p> </li> <li> <code>tensor_forward</code>             \u2013              <p>Rotate the tensor from the old_cell's orient to the new_cell's orient.</p> </li> <li> <code>tensor_backward</code>             \u2013              <p>Rotate the tensor back from the new_cell to the old_cell. Same as Prism.tensor_to_ase</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>old_cell</code>           \u2013            </li> <li> <code>new_cell</code>           \u2013            </li> <li> <code>R</code>           \u2013            </li> </ul>"},{"location":"cell/#asext.cell.CellTransform.old_cell","title":"<code>old_cell = np.asarray(old_cell, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"cell/#asext.cell.CellTransform.new_cell","title":"<code>new_cell = np.asarray(new_cell, dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"cell/#asext.cell.CellTransform.R","title":"<code>R = _polar_rotation(A)</code>  <code>instance-attribute</code>","text":""},{"location":"cell/#asext.cell.CellTransform.vectors_forward","title":"<code>vectors_forward(vec: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate vectors from the old_cell's orient to the new_cell's orient.</p> <p>Parameters:</p> <ul> <li> <code>vec</code>               (<code>ndarray</code>)           \u2013            <p>Nx3 matrix represent the vector properties. (positions, forces, etc. each row is a vector)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotated vectors.</p> </li> </ul>"},{"location":"cell/#asext.cell.CellTransform.vectors_backward","title":"<code>vectors_backward(vec: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate vectors back from the new_cell to the old_cell. Same as Prism.vector_to_ase</p>"},{"location":"cell/#asext.cell.CellTransform.tensor_forward","title":"<code>tensor_forward(tensor: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate the tensor from the old_cell's orient to the new_cell's orient. (T' = R\u1d40 T R) rotates the tensor into the rotated coordinate system</p> <p>Parameters:</p> <ul> <li> <code>tensor</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the tensor properties. (e.g., 3x3 stress tensor)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Transformed tensor.</p> </li> </ul>"},{"location":"cell/#asext.cell.CellTransform.tensor_backward","title":"<code>tensor_backward(tensor: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Rotate the tensor back from the new_cell to the old_cell. Same as Prism.tensor_to_ase (T = R T' R\u1d40) rotates the tensor back into the original coordinate system</p>"},{"location":"cell/#asext.cell.make_upper_triangular_cell","title":"<code>make_upper_triangular_cell(atoms: Atoms, zero_tol: float = 1e-12) -&gt; Atoms</code>","text":"<p>Atoms with a box is an upper triangular matrix is a requirement to run <code>NPT</code> class in ASE. [[ ax, ay, az ]  [  0, by, bz ]  [  0,  0, cz ]]</p>"},{"location":"cell/#asext.cell.make_lower_triangular_cell","title":"<code>make_lower_triangular_cell(atoms: Atoms, zero_tol: float = 1e-12) -&gt; Atoms</code>","text":"<p>Converts the cell matrix of <code>atoms</code> into a lower triangular, to be used in LAMMPS: [[ ax,  0,  0 ]  [ bx, by,  0 ]  [ cx, cy, cz ]]</p>"},{"location":"cell/#asext.cell.make_triangular_cell_extxyz","title":"<code>make_triangular_cell_extxyz(extxyz_file: str, form: str = 'lower') -&gt; None</code>","text":"<p>Make the cell of atoms in extxyz file to be triangular. Args:     extxyz_file (str): Path to the extxyz file.     form (str): 'upper' or 'lower'. Defaults to 'lower'.</p>"},{"location":"cell/#asext.cell.rotate_struct_property","title":"<code>rotate_struct_property(struct: Atoms, new_cell: np.ndarray, wrap: bool = False, custom_vector_props: list[str] | None = None, custom_tensor_props: list[str] | None = None) -&gt; Atoms</code>","text":"<p>Rotate atomic structure and its properties to match a new cell orientation.</p> <p>Parameters:</p> <ul> <li> <code>struct</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object.</p> </li> <li> <code>new_cell</code>               (<code>ndarray</code>)           \u2013            <p>3x3 matrix represent the new cell.</p> </li> <li> <code>wrap</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, wrap atoms into the new cell.</p> </li> <li> <code>custom_vector_props</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of vector properties to rotate. This allows to set vector properties with custom names.</p> </li> <li> <code>custom_tensor_props</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>List of tensor properties to rotate. This allows to set tensor properties with custom names.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>ase.Atoms: Atoms object with rotated properties.</p> </li> </ul> Note <ul> <li>Important note: <code>deepcopy(struct)</code> copies the <code>struct.calc</code> object, but <code>struct.copy()</code> does not.</li> </ul>"},{"location":"io/","title":"io","text":""},{"location":"io/#asext.io","title":"<code>asext.io</code>","text":"<p>Modules:</p> <ul> <li> <code>lmpdata</code>           \u2013            </li> <li> <code>readwrite</code>           \u2013            </li> </ul>"},{"location":"io/#asext.io.lmpdata","title":"<code>lmpdata</code>","text":"<p>Functions:</p> <ul> <li> <code>read_lammps_dump_text</code>             \u2013              <p>Process cleartext lammps dumpfiles</p> </li> <li> <code>write_lammps_data</code>             \u2013              <p>Write atomic structure data to a LAMMPS data file.</p> </li> </ul>"},{"location":"io/#asext.io.lmpdata.read_lammps_dump_text","title":"<code>read_lammps_dump_text(file: str, index=-1, **kwargs)</code>","text":"<p>Process cleartext lammps dumpfiles</p> <p>:param fileobj: filestream providing the trajectory data :param index: integer or slice object (default: get the last timestep) :returns: list of Atoms objects :rtype: list</p> <p>Notes: - This function is a modified version of <code>ase.io.lammpsrun.read_lammps_dump_text</code> to allow storing atom types if <code>type</code> column is given in the LAMMPS dump file.</p>"},{"location":"io/#asext.io.lmpdata.write_lammps_data","title":"<code>write_lammps_data(file: str, atoms: Atoms, *, specorder: list = None, reduce_cell: bool = False, force_skew: bool = False, prismobj: Prism = None, write_image_flags: bool = False, masses: bool = False, velocities: bool = False, units: str = 'metal', bonds: bool = True, atom_style: str = 'atomic')</code>","text":"<p>Write atomic structure data to a LAMMPS data file.</p>"},{"location":"io/#asext.io.lmpdata.write_lammps_data--parameters","title":"Parameters","text":"<p>fd : file|str     File to which the output will be written. atoms : Atoms     Atoms to be written. specorder : list[str], optional     Chemical symbols in the order of LAMMPS atom types, by default None force_skew : bool, optional     Force to write the cell as a     <code>triclinic &lt;https://docs.lammps.org/Howto_triclinic.html&gt;</code>__ box,     by default False reduce_cell : bool, optional     Whether the cell shape is reduced or not, by default False prismobj : Prism|None, optional     Prism, by default None write_image_flags : bool, default False     If True, the image flags, i.e., in which images of the periodic     simulation box the atoms are, are written. masses : bool, optional     Whether the atomic masses are written or not, by default False velocities : bool, optional     Whether the atomic velocities are written or not, by default False units : str, optional     <code>LAMMPS units &lt;https://docs.lammps.org/units.html&gt;</code>,     by default 'metal' bonds : bool, optional     Whether the bonds are written or not. Bonds can only be written     for atom_style='full', by default True atom_style : {'atomic', 'charge', 'full'}, optional     <code>LAMMPS atom style &lt;https://docs.lammps.org/atom_style.html&gt;</code>,     by default 'atomic'</p> <p>Notes: - This function is a modified version of <code>ase.io.lammpsdata.write_lammps_data</code> to allow writing atom types based on <code>atoms.arrays['type']</code> if it exists. Otherwise, the atom types are assigned based on the order of <code>specorder</code> or sorted chemical symbols.</p>"},{"location":"io/#asext.io.readwrite","title":"<code>readwrite</code>","text":"<p>Functions:</p> <ul> <li> <code>read_extxyz</code>             \u2013              <p>Read extxyz file. The existing <code>ase.io.read</code> returns a single Atoms object if file contains only one frame. This function will return a list of Atoms object.</p> </li> <li> <code>write_extxyz</code>             \u2013              <p>Write a list of Atoms object to an extxyz file. The existing <code>ase.io.write</code> function does not support writing file if the parent directory does not exist. This function will overcome this problem.</p> </li> <li> <code>read_lmpdump</code>             \u2013              <p>Shortcut to <code>ase.io.lammpsrun.read_lammps_dump</code> function.</p> </li> <li> <code>write_lmpdata</code>             \u2013              <p>Shortcut to <code>ase.io.lammpsdata.write_lammps_data</code> function.</p> </li> <li> <code>extxyz2lmpdata</code>             \u2013              <p>Convert extxyz file to LAMMPS data file.</p> </li> <li> <code>lmpdata2extxyz</code>             \u2013              <p>Convert LAMMPS data file to extxyz file.</p> </li> <li> <code>lmpdump2extxyz</code>             \u2013              <p>Convert LAMMPS dump file to extxyz file.</p> </li> </ul>"},{"location":"io/#asext.io.readwrite.read_extxyz","title":"<code>read_extxyz(extxyz_file: str, index=':') -&gt; list[Atoms]</code>","text":"<p>Read extxyz file. The existing <code>ase.io.read</code> returns a single Atoms object if file contains only one frame. This function will return a list of Atoms object.</p> <p>Parameters:</p> <ul> <li> <code>extxyz_file</code>               (<code>str</code>)           \u2013            <p>Path to the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list[Atoms]</code> )          \u2013            <p>List of Atoms object.</p> </li> </ul> Note <ul> <li><code>ase.io.read</code> returns a single Atoms object or a list of Atoms object, depending on the <code>index</code> argument.<ul> <li><code>index=\":\"</code> will always return a list.</li> <li><code>index=0</code> or <code>index=-1</code> will return a single Atoms object.</li> </ul> </li> <li>this function will always return a list of Atoms object, even <code>index=0</code> or <code>index=-1</code></li> </ul>"},{"location":"io/#asext.io.readwrite.write_extxyz","title":"<code>write_extxyz(outfile: str, structs: list[Atoms]) -&gt; None</code>","text":"<p>Write a list of Atoms object to an extxyz file. The existing <code>ase.io.write</code> function does not support writing file if the parent directory does not exist. This function will overcome this problem.</p> <p>Parameters:</p> <ul> <li> <code>structs</code>               (<code>list</code>)           \u2013            <p>List of Atoms object.</p> </li> <li> <code>outfile</code>               (<code>str</code>)           \u2013            <p>Path to the output file.</p> </li> </ul>"},{"location":"io/#asext.io.readwrite.read_lmpdump","title":"<code>read_lmpdump(lmpdump_file: str, index=-1, units='metal', **kwargs) -&gt; list[Atoms]</code>","text":"<p>Shortcut to <code>ase.io.lammpsrun.read_lammps_dump</code> function.</p> <p>Parameters:</p> <ul> <li> <code>lmpdump_file</code>               (<code>str</code>)           \u2013            <p>Path to the LAMMPS dump file.</p> </li> <li> <code>index</code>               (<code>int | list[int]</code>, default:                   <code>-1</code> )           \u2013            <p>integer or slice object (default: get the last timestep)</p> </li> <li> <code>order</code>               (<code>bool</code>)           \u2013            <p>sort atoms by id. Might be faster to turn off. Default: True</p> </li> <li> <code>specorder</code>               (<code>list[str]</code>)           \u2013            <p>list of species to map lammps types to ase-species. Default: None</p> </li> <li> <code>units</code>               (<code>str</code>, default:                   <code>'metal'</code> )           \u2013            <p>lammps units for unit transformation between lammps and ase</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list[Atoms]</code> )          \u2013            <p>List of Atoms object.</p> </li> </ul>"},{"location":"io/#asext.io.readwrite.write_lmpdata","title":"<code>write_lmpdata(file: str, atoms: Atoms, *, specorder: list = None, reduce_cell: bool = False, force_skew: bool = False, prismobj: Prism = None, write_image_flags: bool = False, masses: bool = True, velocities: bool = False, units: str = 'metal', bonds: bool = True, atom_style: str = 'atomic') -&gt; None</code>","text":"<p>Shortcut to <code>ase.io.lammpsdata.write_lammps_data</code> function.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>str</code>)           \u2013            <p>File to which the output will be written.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms to be written.</p> </li> <li> <code>specorder</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>Chemical symbols in the order of LAMMPS atom types, by default None</p> </li> <li> <code>force_skew</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force to write the cell as a <code>triclinic &lt;https://docs.lammps.org/Howto_triclinic.html&gt;</code> box, by default False</p> </li> <li> <code>reduce_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the cell shape is reduced or not, by default False</p> </li> <li> <code>prismobj</code>               (<code>Prism | None</code>, default:                   <code>None</code> )           \u2013            <p>Prism, by default None</p> </li> <li> <code>write_image_flags</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>default False. If True, the image flags, i.e., in which images of the periodic simulation box the atoms are, are written.</p> </li> <li> <code>masses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the atomic masses are written or not, by default True</p> </li> <li> <code>velocities</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the atomic velocities are written or not, by default False</p> </li> <li> <code>units</code>               (<code>str</code>, default:                   <code>'metal'</code> )           \u2013            <p><code>LAMMPS units &lt;https://docs.lammps.org/units.html&gt;</code>, by default 'metal'</p> </li> <li> <code>bonds</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the bonds are written or not. Bonds can only be written for atom_style='full', by default True</p> </li> <li> <code>atom_style </code>           \u2013            <p>{'atomic', 'charge', 'full'}, optional. <code>LAMMPS atom style &lt;https://docs.lammps.org/atom_style.html&gt;</code>, by default 'atomic'</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"io/#asext.io.readwrite.extxyz2lmpdata","title":"<code>extxyz2lmpdata(extxyz_file: str, lmpdata_file: str, masses: bool = True, units: str = 'metal', atom_style: str = 'atomic', **kwargs) -&gt; list[str]</code>","text":"<p>Convert extxyz file to LAMMPS data file. Note:     - need to save 'original_cell' to able to revert the original orientation of the crystal.     - Use <code>atoms.arrays['type']</code> to set atom types when convert from <code>extxyz</code> to <code>lammpsdata</code> file.</p>"},{"location":"io/#asext.io.readwrite.lmpdata2extxyz","title":"<code>lmpdata2extxyz(lmpdata_file: str, extxyz_file: str, original_cell_file: str = None)</code>","text":"<p>Convert LAMMPS data file to extxyz file.</p>"},{"location":"io/#asext.io.readwrite.lmpdump2extxyz","title":"<code>lmpdump2extxyz(lmpdump_file: str, extxyz_file: str, index: int | slice = -1, original_cell_file: str = None, stress_file: str = None, lammps_units: str = 'metal')</code>","text":"<p>Convert LAMMPS dump file to extxyz file.</p> <p>Parameters:</p> <ul> <li> <code>lmpdump_file</code>               (<code>str</code>)           \u2013            <p>Path to the LAMMPS dump file.</p> </li> <li> <code>extxyz_file</code>               (<code>str</code>)           \u2013            <p>Path to the output extxyz file.</p> </li> <li> <code>original_cell_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the text file contains original_cell. It should a simple text file that can write/read with numpy. If not provided, try to find in the same directory as <code>lmpdump_file</code> with the extension <code>.original_cell</code>. Defaults to None.</p> </li> <li> <code>stress_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the text file contains stress tensor. Defaults to None.</p> </li> </ul> Restriction <ul> <li>Current ver: stress is mapped based on frame_index, it requires that frames in text stress file must be in the same \"length and order\" as in the LAMMPS dump file.</li> <li><code>struct.info.get(\"timestep\")</code> is a new feature in ASE 3.25 ?</li> </ul>"},{"location":"struct/","title":"struct","text":""},{"location":"struct/#asext.struct","title":"<code>asext.struct</code>","text":"<p>Functions:</p> <ul> <li> <code>strain_struct</code>             \u2013              <p>Apply engineering strain to an ASE Atoms structure along lattice vectors a, b, c.</p> </li> <li> <code>perturb_struct</code>             \u2013              <p>Perturb the atoms by random displacements. This method adds random displacements to the atomic positions. See more</p> </li> <li> <code>slice_struct</code>             \u2013              <p>Slice structure into the first subcell by given numbers along a, b, c (cell vector) directions.</p> </li> <li> <code>align_struct_min_pos</code>             \u2013              <p>Align min atoms position to the min cell corner (0,0,0)</p> </li> <li> <code>set_vacuum</code>             \u2013              <p>This function sets vacuum along cell vectors a, b, c.</p> </li> <li> <code>check_bad_box_extxyz</code>             \u2013              <p>Check structure in extxyz file whether it has bad box.</p> </li> <li> <code>check_bad_box</code>             \u2013              <p>Check if a simulation box is \"bad\" based on given criteria.</p> </li> </ul>"},{"location":"struct/#asext.struct.strain_struct","title":"<code>strain_struct(struct_in: Atoms, strains: list = [0, 0, 0]) -&gt; Atoms</code>","text":"<p>Apply engineering strain to an ASE Atoms structure along lattice vectors a, b, c.</p> <p>Parameters:</p> <ul> <li> <code>struct</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object.</p> </li> <li> <code>strains</code>               (<code>list[float]</code>, default:                   <code>[0, 0, 0]</code> )           \u2013            <p>Engineering strains [\u03b5_a, \u03b5_b, \u03b5_c]. New_length = old_length * (1 + \u03b5).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>atoms</code> (              <code>Atoms</code> )          \u2013            <p>New strained structure with scaled cell and atom positions.</p> </li> </ul>"},{"location":"struct/#asext.struct.perturb_struct","title":"<code>perturb_struct(struct: Atoms, std_disp: float) -&gt; Atoms</code>","text":"<p>Perturb the atoms by random displacements. This method adds random displacements to the atomic positions. See more</p>"},{"location":"struct/#asext.struct.slice_struct","title":"<code>slice_struct(struct_in: Atoms, slice_num=(1, 1, 1), tol=1e-05) -&gt; Atoms</code>","text":"<p>Slice structure into the first subcell by given numbers along a, b, c (cell vector) directions.</p>"},{"location":"struct/#asext.struct.align_struct_min_pos","title":"<code>align_struct_min_pos(struct: Atoms) -&gt; Atoms</code>","text":"<p>Align min atoms position to the min cell corner (0,0,0)</p>"},{"location":"struct/#asext.struct.set_vacuum","title":"<code>set_vacuum(struct_in: Atoms, distances: list = [0.0, 0.0, 0.0]) -&gt; Atoms</code>","text":"<p>This function sets vacuum along cell vectors a, b, c.</p> <p>Parameters:</p> <ul> <li> <code>struct</code>               (<code>Atoms</code>)           \u2013            <p>ASE Atoms object to add vacuum.</p> </li> <li> <code>distances</code>               (<code>list</code>, default:                   <code>[0.0, 0.0, 0.0]</code> )           \u2013            <p>Distances to add along cell vectors a, b, c (not x, y, z dims in Cartersian axes). Must be a list of 3 floats.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>struct</code> (              <code>Atoms</code> )          \u2013            <p>A new Atoms object with an expanded cell and centered atoms.</p> </li> </ul> Notes <ul> <li><code>atoms.center()</code> sets vacuum on both sides of the cell along the specified axis. So the total vacuum is twice the input value. This function is different in that, it set total vacuum equal to the input value.</li> </ul>"},{"location":"struct/#asext.struct.check_bad_box_extxyz","title":"<code>check_bad_box_extxyz(extxyz_file: str, criteria: dict = {'length_ratio': 100, 'wrap_ratio': 0.5, 'tilt_ratio': 0.5}) -&gt; list[int]</code>","text":"<p>Check structure in extxyz file whether it has bad box. Return:     a file remarking the bad box frames.</p>"},{"location":"struct/#asext.struct.check_bad_box","title":"<code>check_bad_box(struct: Atoms, criteria: dict = {'length_ratio': 20, 'wrap_ratio': 0.5, 'tilt_ratio': 0.5}) -&gt; bool</code>","text":"<p>Check if a simulation box is \"bad\" based on given criteria.</p>"},{"location":"struct/#asext.struct.check_bad_box--args","title":"Args:","text":"<p>struct : ase.Atoms     Atoms object containing the atomic structure. criteria : dict     A dictionary of criteria to check, which contains pairs of {'criteria_name': threshold_value}.     Available criteria:     - <code>length_ratio</code>: The ratio of the longest to the shortest cell vector.       - Formula: max(|a|, |b|, |c|) / min(|a|, |b|, |c|)       - Prevents highly elongated simulation boxes.     - <code>wrap_ratio</code>: Checks if one cell vector component is excessively wrapped around another.       - Formula: [b_x / a_x, c_y / b_y, c_x / a_x]       - Prevents excessive skewing.     - <code>tilt_ratio</code>: Measures tilting of cell vectors relative to their axes.       - Formula: [b_x / b_y, c_y / c_z, c_x / c_z]       - Avoids excessive tilting that may disrupt periodic boundaries.</p>"},{"location":"struct/#asext.struct.check_bad_box--returns","title":"Returns:","text":"<p>is_bad : bool     True if the simulation box violates any of the given criteria, otherwise False.</p>"},{"location":"struct/#asext.struct.check_bad_box--raises","title":"Raises:","text":"<p>RuntimeError     If an unknown criterion key is provided.</p>"},{"location":"schema_doc/config_remotes/","title":"Schema to configure remote machines","text":"<p>In the below schema, the machine and resources dicts accept all keywords as in the dpdispatcher package</p> <ul> <li>Support romote machines of various batch types: Bash, Slurm, OpenPBS, SGE, TORQUE, LSF, OpenAPI, ...</li> <li>Support various connection contexts: Local, SSH, HDFS, OpenAPI, ...</li> </ul>"}]}